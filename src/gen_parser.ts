/* AutoGenerated Code, changes may be overwritten
* INPUT GRAMMAR:
* ---
* import { Environment } from "./env";
* import { callFunc, idxList, Value } from "./values";
* import { unescapeChars } from "./letters";
* import * as Asserts from "./asserts";
* import * as Checks from "./checks";
* import { orBinOp, orQuickBinOp, andBinOp, andQuickBinOp,
*     binOpEvalFn, binOpQuickEvalFn } from "./binops";
* import { objLookupsEval, postfixArgsEval, csArgsEval, prefEval, EvalFn } from "./evals";
* import { qEvalToEval } from "./evals";
* import * as Quick from "./quickevals";
* ---
* Program     := stmts=AsgnStmt* _
* AsgnStmt    := IfStmt
*              | BlockStmt
*              | WhenStmt
*              | ForStmt
*              | ContinueStmt
*              | BreakStmt
*              | CtlchStmt
*              | FunctionStmt
*              | ReturnStmt
*              | AssignStmt
*              | DefnStmt
*              | Expr
* NonAsgnStmt := IfStmt
*              | WhenStmt
*              | ForStmt
*              | ContinueStmt
*              | BreakStmt
*              | ReturnStmt
*              | BlockStmt
*              | AssignStmt
*              | Expr
* IfStmt      := _ 'if' &gap expr=Expr &gap stmt=NonAsgnStmt elsebranch={_ 'or' &gap stmt=NonAsgnStmt}?
* BlockStmt   := _ '{' blk=AsgnStmt* _ '}'
* WhenStmt   := _ 'when' expr=Expr &gap stmt=NonAsgnStmt
* ForStmt      := _ 'for' &gap id=ID _ 'in' _ '\('strt=Expr _ ',' end=Expr step={_ ',' step=Expr}? _ '\)' stmt=NonAsgnStmt
* DefnStmt    := _ idstart=@ id=ID idend=@ _ ':=' _ expr=Expr
* AssignStmt   := _ lhs=Postfix _ op=AsgnOp _ expr=Expr
* FunctionStmt  := _ 'function' &gap id=ID _ '\(' args=CSIDs? _ '\)' _ '{'
*     stmts=AsgnStmt*
* _ '}'
* CtlchStmt   := _ 'object' &gap id=ID tuis={_ 'รณ' &gap parentstart=@ id=ID parentend=@}? _ '{'
*     functions=FunctionStmt*
* _ '}'
* BreakStmt    := _ 'break'
* ContinueStmt      := _ 'continue'
* ReturnStmt  := _ 'return' &gap exp=Expr?
* Expr        := And
* And         := start=@ head=Or tail={_ '\&' trm=Or}* end=@
*                .evalfn = EvalFn { return andBinOp(this); }
*                .qeval = Quick.MaybeEv { return andQuickBinOp(this); }
* Or          := start=@ head=Eq tail={_ '\|' trm=Eq}* end=@
*                .evalfn = EvalFn { return orBinOp(this) }
*                .qeval = Quick.MaybeEv { return orQuickBinOp(this); }
* Eq          := start=@ head=Comp tail={_ op='[!=]=' trm=Comp}* end=@
*                .evalfn = EvalFn { return binOpEvalFn(this) }
*                .qeval = Quick.MaybeEv { return binOpQuickEvalFn(this); }
* Comp        := start=@ head=Sum tail={_ op=Compare trm=Sum}* end=@
*                .evalfn = EvalFn { return binOpEvalFn(this) }
*                .qeval = Quick.MaybeEv { return binOpQuickEvalFn(this); }
* Sum         := start=@ head=Product tail={_ op=PlusMinus trm=Product}* end=@
*                .evalfn = EvalFn { return binOpEvalFn(this) }
*                .qeval = Quick.MaybeEv { return binOpQuickEvalFn(this); }
* Product     := start=@ head=Prefix tail={_ op=MulDiv trm=Prefix}* end=@
*                .evalfn = EvalFn { return binOpEvalFn(this); }
*                .qeval = Quick.MaybeEv { return binOpQuickEvalFn(this); }
* Prefix      := _ start=@ op='-|!'? pf=Postfix end=@
*                .evalfn = EvalFn { return prefEval(this); }
*                .qeval = Quick.MaybeEv { return Quick.qPrefEval(this); }
* Postfix     := start=@ at=ObjLookups ops=PostOp* end=@
*                .evalfn = EvalFn { return postfixArgsEval(this); }
*                .qeval = Quick.MaybeEv { return Quick.qPostfixArgsEval(this); }
* ObjLookups  := start=@ attrs={id=ID '@' !wspace}* root=Atom end=@
*                .evalfn = EvalFn { return objLookupsEval(this); }
*                .qeval = Quick.MaybeEv { return Quick.qObjLookupsEval(this); }
* PostOp      := '\(' args=CSArgs? _ '\)' | '\[' expr=Expr _ '\]'
* Atom        :=  _ '\(' trm=Expr '\)'
*                .evalfn = EvalFn { return (env: Environment) => this.trm.evalfn(env); }
*                .qeval = Quick.MaybeEv {
*                     const childF = this.trm.qeval;
*                     return childF === null ? null : childF.bind(this.trm);
*                }
*              | ID
*              | Letters
*              | Int
*              | Bool
*              | Void
*              | ListLit
* ListLit     := _ '\[' els=CSArgs? _ '\]'
*                .evalfn = EvalFn {
*                    return (env: Environment) => this.els ? this.els.evalfn(env) : Promise.resolve([]);
*                }
*                .qeval = Quick.MaybeEv { return Quick.qListLitEval(this); }
* CSArgs      := start=@ head=Expr tail={_ ',' exp=Expr}* end=@
*                .evalfn = (env:Environment)=>Promise<Value[]> { return csArgsEval(this); }
*                .qeval = ((env:Environment)=>Value[])|null { return Quick.qCSArgsEval(this); }
* CSIDs       := head=ID tail={_ ',' id=ID}*
* ID          := _ !{Keyword gap} start=@ id='[a-zA-Z_]+' end=@
*                .evalfn = EvalFn { return qEvalToEval(Quick.qIdEval(this.id, this.start, this.end)); }
*                .qeval = Quick.EvalFn { return Quick.qIdEval(this.id, this.start, this.end); }
* Bool        := _ bool='true|false'
*                .evalfn = EvalFn { return qEvalToEval(Quick.qBoolEval(this.bool)); }
*                .qeval = Quick.EvalFn { return Quick.qBoolEval(this.bool); }
* Void     := _ 'void'
*                .evalfn = EvalFn { return () => Promise.resolve(null); }
*                .qeval = Quick.EvalFn { return () => null; }
* Int         := _ int='-?[0-9]+(?:\.[0-9]+)?'
*                .evalfn = EvalFn { return qEvalToEval(Quick.qIntEval(this.int)); }
*                .qeval = Quick.EvalFn { return Quick.qIntEval(this.int); }
* Letters   := _ '\'' val='([^\'\\]|\\.)*' '\''
*                .evalfn = EvalFn { return qEvalToEval(Quick.qLettersEval(this.val)); }
*                .qeval = Quick.EvalFn { return Quick.qLettersEval(this.val); }
* _           := wspace*
* wspace      := '(?:\s|>--(?:(?!--<).)*(--<|\n|$))'
* gap         := { wspace | '[^a-zA-Z0-9]' }+ | '$'
* PlusMinus   := '\+|-'
* AsgnOp      := '=|\+=|\*=|-=|%=|\/='
* MulDiv      := '\*|\/\/|%|\/'
* Compare     := '<=|>=|<|>'
* Keyword     := 'if' | 'or' | 'when' | 'true' |'false'
*     | 'function' | 'continue' | 'void' | 'return' | 'object'
*/

import { Environment } from "./env";
import { callFunc, idxList, Value } from "./values";
import { unescapeChars } from "./letters";
import * as Asserts from "./asserts";
import * as Checks from "./checks";
import { orBinOp, orQuickBinOp, andBinOp, andQuickBinOp,
    binOpEvalFn, binOpQuickEvalFn } from "./binops";
import { objLookupsEval, postfixArgsEval, csArgsEval, prefEval, EvalFn } from "./evals";
import { qEvalToEval } from "./evals";
import * as Quick from "./quickevals";

type Nullable<T> = T | null;
type $$RuleType<T> = (log?: (msg: string) => void) => Nullable<T>;
export interface ContextRecorder {
    record(pos: PosInfo, depth: number, result: any, negating: boolean, extraInfo: string[]): void;
}
interface ASTNodeIntf {
    kind: ASTKinds;
}
export enum ASTKinds {
    Program,
    AsgnStmt_1,
    AsgnStmt_2,
    AsgnStmt_3,
    AsgnStmt_4,
    AsgnStmt_5,
    AsgnStmt_6,
    AsgnStmt_7,
    AsgnStmt_8,
    AsgnStmt_9,
    AsgnStmt_10,
    AsgnStmt_11,
    AsgnStmt_12,
    NonAsgnStmt_1,
    NonAsgnStmt_2,
    NonAsgnStmt_3,
    NonAsgnStmt_4,
    NonAsgnStmt_5,
    NonAsgnStmt_6,
    NonAsgnStmt_7,
    NonAsgnStmt_8,
    NonAsgnStmt_9,
    IfStmt,
    IfStmt_$0,
    BlockStmt,
    WhenStmt,
    ForStmt,
    ForStmt_$0,
    DefnStmt,
    AssignStmt,
    FunctionStmt,
    CtlchStmt,
    CtlchStmt_$0,
    BreakStmt,
    ContinueStmt,
    ReturnStmt,
    Expr,
    And,
    And_$0,
    Or,
    Or_$0,
    Eq,
    Eq_$0,
    Comp,
    Comp_$0,
    Sum,
    Sum_$0,
    Product,
    Product_$0,
    Prefix,
    Postfix,
    ObjLookups,
    ObjLookups_$0,
    PostOp_1,
    PostOp_2,
    Atom_1,
    Atom_2,
    Atom_3,
    Atom_4,
    Atom_5,
    Atom_6,
    Atom_7,
    ListLit,
    CSArgs,
    CSArgs_$0,
    CSIDs,
    CSIDs_$0,
    ID,
    ID_$0,
    Bool,
    Void,
    Int,
    Letters,
    _,
    wspace,
    gap_1,
    gap_2,
    gap_$0_1,
    gap_$0_2,
    PlusMinus,
    AsgnOp,
    MulDiv,
    Compare,
    Keyword_1,
    Keyword_2,
    Keyword_3,
    Keyword_4,
    Keyword_5,
    Keyword_6,
    Keyword_7,
    Keyword_8,
    Keyword_9,
    Keyword_10,
}
export interface Program {
    kind: ASTKinds.Program;
    stmts: AsgnStmt[];
}
export type AsgnStmt = AsgnStmt_1 | AsgnStmt_2 | AsgnStmt_3 | AsgnStmt_4 | AsgnStmt_5 | AsgnStmt_6 | AsgnStmt_7 | AsgnStmt_8 | AsgnStmt_9 | AsgnStmt_10 | AsgnStmt_11 | AsgnStmt_12;
export type AsgnStmt_1 = IfStmt;
export type AsgnStmt_2 = BlockStmt;
export type AsgnStmt_3 = WhenStmt;
export type AsgnStmt_4 = ForStmt;
export type AsgnStmt_5 = ContinueStmt;
export type AsgnStmt_6 = BreakStmt;
export type AsgnStmt_7 = CtlchStmt;
export type AsgnStmt_8 = FunctionStmt;
export type AsgnStmt_9 = ReturnStmt;
export type AsgnStmt_10 = AssignStmt;
export type AsgnStmt_11 = DefnStmt;
export type AsgnStmt_12 = Expr;
export type NonAsgnStmt = NonAsgnStmt_1 | NonAsgnStmt_2 | NonAsgnStmt_3 | NonAsgnStmt_4 | NonAsgnStmt_5 | NonAsgnStmt_6 | NonAsgnStmt_7 | NonAsgnStmt_8 | NonAsgnStmt_9;
export type NonAsgnStmt_1 = IfStmt;
export type NonAsgnStmt_2 = WhenStmt;
export type NonAsgnStmt_3 = ForStmt;
export type NonAsgnStmt_4 = ContinueStmt;
export type NonAsgnStmt_5 = BreakStmt;
export type NonAsgnStmt_6 = ReturnStmt;
export type NonAsgnStmt_7 = BlockStmt;
export type NonAsgnStmt_8 = AssignStmt;
export type NonAsgnStmt_9 = Expr;
export interface IfStmt {
    kind: ASTKinds.IfStmt;
    expr: Expr;
    stmt: NonAsgnStmt;
    elsebranch: Nullable<IfStmt_$0>;
}
export interface IfStmt_$0 {
    kind: ASTKinds.IfStmt_$0;
    stmt: NonAsgnStmt;
}
export interface BlockStmt {
    kind: ASTKinds.BlockStmt;
    blk: AsgnStmt[];
}
export interface WhenStmt {
    kind: ASTKinds.WhenStmt;
    expr: Expr;
    stmt: NonAsgnStmt;
}
export interface ForStmt {
    kind: ASTKinds.ForStmt;
    id: ID;
    strt: Expr;
    end: Expr;
    step: Nullable<ForStmt_$0>;
    stmt: NonAsgnStmt;
}
export interface ForStmt_$0 {
    kind: ASTKinds.ForStmt_$0;
    step: Expr;
}
export interface DefnStmt {
    kind: ASTKinds.DefnStmt;
    idstart: PosInfo;
    id: ID;
    idend: PosInfo;
    expr: Expr;
}
export interface AssignStmt {
    kind: ASTKinds.AssignStmt;
    lhs: Postfix;
    op: AsgnOp;
    expr: Expr;
}
export interface FunctionStmt {
    kind: ASTKinds.FunctionStmt;
    id: ID;
    args: Nullable<CSIDs>;
    stmts: AsgnStmt[];
}
export interface CtlchStmt {
    kind: ASTKinds.CtlchStmt;
    id: ID;
    tuis: Nullable<CtlchStmt_$0>;
    functions: FunctionStmt[];
}
export interface CtlchStmt_$0 {
    kind: ASTKinds.CtlchStmt_$0;
    parentstart: PosInfo;
    id: ID;
    parentend: PosInfo;
}
export interface BreakStmt {
    kind: ASTKinds.BreakStmt;
}
export interface ContinueStmt {
    kind: ASTKinds.ContinueStmt;
}
export interface ReturnStmt {
    kind: ASTKinds.ReturnStmt;
    exp: Nullable<Expr>;
}
export type Expr = And;
export class And {
    public kind: ASTKinds.And = ASTKinds.And;
    public start: PosInfo;
    public head: Or;
    public tail: And_$0[];
    public end: PosInfo;
    public evalfn: EvalFn;
    public qeval: Quick.MaybeEv;
    constructor(start: PosInfo, head: Or, tail: And_$0[], end: PosInfo){
        this.start = start;
        this.head = head;
        this.tail = tail;
        this.end = end;
        this.evalfn = (() => {
        return andBinOp(this);
        })();
        this.qeval = (() => {
        return andQuickBinOp(this);
        })();
    }
}
export interface And_$0 {
    kind: ASTKinds.And_$0;
    trm: Or;
}
export class Or {
    public kind: ASTKinds.Or = ASTKinds.Or;
    public start: PosInfo;
    public head: Eq;
    public tail: Or_$0[];
    public end: PosInfo;
    public evalfn: EvalFn;
    public qeval: Quick.MaybeEv;
    constructor(start: PosInfo, head: Eq, tail: Or_$0[], end: PosInfo){
        this.start = start;
        this.head = head;
        this.tail = tail;
        this.end = end;
        this.evalfn = (() => {
        return orBinOp(this)
        })();
        this.qeval = (() => {
        return orQuickBinOp(this);
        })();
    }
}
export interface Or_$0 {
    kind: ASTKinds.Or_$0;
    trm: Eq;
}
export class Eq {
    public kind: ASTKinds.Eq = ASTKinds.Eq;
    public start: PosInfo;
    public head: Comp;
    public tail: Eq_$0[];
    public end: PosInfo;
    public evalfn: EvalFn;
    public qeval: Quick.MaybeEv;
    constructor(start: PosInfo, head: Comp, tail: Eq_$0[], end: PosInfo){
        this.start = start;
        this.head = head;
        this.tail = tail;
        this.end = end;
        this.evalfn = (() => {
        return binOpEvalFn(this)
        })();
        this.qeval = (() => {
        return binOpQuickEvalFn(this);
        })();
    }
}
export interface Eq_$0 {
    kind: ASTKinds.Eq_$0;
    op: string;
    trm: Comp;
}
export class Comp {
    public kind: ASTKinds.Comp = ASTKinds.Comp;
    public start: PosInfo;
    public head: Sum;
    public tail: Comp_$0[];
    public end: PosInfo;
    public evalfn: EvalFn;
    public qeval: Quick.MaybeEv;
    constructor(start: PosInfo, head: Sum, tail: Comp_$0[], end: PosInfo){
        this.start = start;
        this.head = head;
        this.tail = tail;
        this.end = end;
        this.evalfn = (() => {
        return binOpEvalFn(this)
        })();
        this.qeval = (() => {
        return binOpQuickEvalFn(this);
        })();
    }
}
export interface Comp_$0 {
    kind: ASTKinds.Comp_$0;
    op: Compare;
    trm: Sum;
}
export class Sum {
    public kind: ASTKinds.Sum = ASTKinds.Sum;
    public start: PosInfo;
    public head: Product;
    public tail: Sum_$0[];
    public end: PosInfo;
    public evalfn: EvalFn;
    public qeval: Quick.MaybeEv;
    constructor(start: PosInfo, head: Product, tail: Sum_$0[], end: PosInfo){
        this.start = start;
        this.head = head;
        this.tail = tail;
        this.end = end;
        this.evalfn = (() => {
        return binOpEvalFn(this)
        })();
        this.qeval = (() => {
        return binOpQuickEvalFn(this);
        })();
    }
}
export interface Sum_$0 {
    kind: ASTKinds.Sum_$0;
    op: PlusMinus;
    trm: Product;
}
export class Product {
    public kind: ASTKinds.Product = ASTKinds.Product;
    public start: PosInfo;
    public head: Prefix;
    public tail: Product_$0[];
    public end: PosInfo;
    public evalfn: EvalFn;
    public qeval: Quick.MaybeEv;
    constructor(start: PosInfo, head: Prefix, tail: Product_$0[], end: PosInfo){
        this.start = start;
        this.head = head;
        this.tail = tail;
        this.end = end;
        this.evalfn = (() => {
        return binOpEvalFn(this);
        })();
        this.qeval = (() => {
        return binOpQuickEvalFn(this);
        })();
    }
}
export interface Product_$0 {
    kind: ASTKinds.Product_$0;
    op: MulDiv;
    trm: Prefix;
}
export class Prefix {
    public kind: ASTKinds.Prefix = ASTKinds.Prefix;
    public start: PosInfo;
    public op: Nullable<string>;
    public pf: Postfix;
    public end: PosInfo;
    public evalfn: EvalFn;
    public qeval: Quick.MaybeEv;
    constructor(start: PosInfo, op: Nullable<string>, pf: Postfix, end: PosInfo){
        this.start = start;
        this.op = op;
        this.pf = pf;
        this.end = end;
        this.evalfn = (() => {
        return prefEval(this);
        })();
        this.qeval = (() => {
        return Quick.qPrefEval(this);
        })();
    }
}
export class Postfix {
    public kind: ASTKinds.Postfix = ASTKinds.Postfix;
    public start: PosInfo;
    public at: ObjLookups;
    public ops: PostOp[];
    public end: PosInfo;
    public evalfn: EvalFn;
    public qeval: Quick.MaybeEv;
    constructor(start: PosInfo, at: ObjLookups, ops: PostOp[], end: PosInfo){
        this.start = start;
        this.at = at;
        this.ops = ops;
        this.end = end;
        this.evalfn = (() => {
        return postfixArgsEval(this);
        })();
        this.qeval = (() => {
        return Quick.qPostfixArgsEval(this);
        })();
    }
}
export class ObjLookups {
    public kind: ASTKinds.ObjLookups = ASTKinds.ObjLookups;
    public start: PosInfo;
    public attrs: ObjLookups_$0[];
    public root: Atom;
    public end: PosInfo;
    public evalfn: EvalFn;
    public qeval: Quick.MaybeEv;
    constructor(start: PosInfo, attrs: ObjLookups_$0[], root: Atom, end: PosInfo){
        this.start = start;
        this.attrs = attrs;
        this.root = root;
        this.end = end;
        this.evalfn = (() => {
        return objLookupsEval(this);
        })();
        this.qeval = (() => {
        return Quick.qObjLookupsEval(this);
        })();
    }
}
export interface ObjLookups_$0 {
    kind: ASTKinds.ObjLookups_$0;
    id: ID;
}
export type PostOp = PostOp_1 | PostOp_2;
export interface PostOp_1 {
    kind: ASTKinds.PostOp_1;
    args: Nullable<CSArgs>;
}
export interface PostOp_2 {
    kind: ASTKinds.PostOp_2;
    expr: Expr;
}
export type Atom = Atom_1 | Atom_2 | Atom_3 | Atom_4 | Atom_5 | Atom_6 | Atom_7;
export class Atom_1 {
    public kind: ASTKinds.Atom_1 = ASTKinds.Atom_1;
    public trm: Expr;
    public evalfn: EvalFn;
    public qeval: Quick.MaybeEv;
    constructor(trm: Expr){
        this.trm = trm;
        this.evalfn = (() => {
        return (env: Environment) => this.trm.evalfn(env);
        })();
        this.qeval = (() => {
        const childF = this.trm.qeval;
                    return childF === null ? null : childF.bind(this.trm);
        })();
    }
}
export type Atom_2 = ID;
export type Atom_3 = Letters;
export type Atom_4 = Int;
export type Atom_5 = Bool;
export type Atom_6 = Void;
export type Atom_7 = ListLit;
export class ListLit {
    public kind: ASTKinds.ListLit = ASTKinds.ListLit;
    public els: Nullable<CSArgs>;
    public evalfn: EvalFn;
    public qeval: Quick.MaybeEv;
    constructor(els: Nullable<CSArgs>){
        this.els = els;
        this.evalfn = (() => {
        return (env: Environment) => this.els ? this.els.evalfn(env) : Promise.resolve([]);
        })();
        this.qeval = (() => {
        return Quick.qListLitEval(this);
        })();
    }
}
export class CSArgs {
    public kind: ASTKinds.CSArgs = ASTKinds.CSArgs;
    public start: PosInfo;
    public head: Expr;
    public tail: CSArgs_$0[];
    public end: PosInfo;
    public evalfn: (env:Environment)=>Promise<Value[]>;
    public qeval: ((env:Environment)=>Value[])|null;
    constructor(start: PosInfo, head: Expr, tail: CSArgs_$0[], end: PosInfo){
        this.start = start;
        this.head = head;
        this.tail = tail;
        this.end = end;
        this.evalfn = (() => {
        return csArgsEval(this);
        })();
        this.qeval = (() => {
        return Quick.qCSArgsEval(this);
        })();
    }
}
export interface CSArgs_$0 {
    kind: ASTKinds.CSArgs_$0;
    exp: Expr;
}
export interface CSIDs {
    kind: ASTKinds.CSIDs;
    head: ID;
    tail: CSIDs_$0[];
}
export interface CSIDs_$0 {
    kind: ASTKinds.CSIDs_$0;
    id: ID;
}
export class ID {
    public kind: ASTKinds.ID = ASTKinds.ID;
    public start: PosInfo;
    public id: string;
    public end: PosInfo;
    public evalfn: EvalFn;
    public qeval: Quick.EvalFn;
    constructor(start: PosInfo, id: string, end: PosInfo){
        this.start = start;
        this.id = id;
        this.end = end;
        this.evalfn = (() => {
        return qEvalToEval(Quick.qIdEval(this.id, this.start, this.end));
        })();
        this.qeval = (() => {
        return Quick.qIdEval(this.id, this.start, this.end);
        })();
    }
}
export interface ID_$0 {
    kind: ASTKinds.ID_$0;
}
export class Bool {
    public kind: ASTKinds.Bool = ASTKinds.Bool;
    public bool: string;
    public evalfn: EvalFn;
    public qeval: Quick.EvalFn;
    constructor(bool: string){
        this.bool = bool;
        this.evalfn = (() => {
        return qEvalToEval(Quick.qBoolEval(this.bool));
        })();
        this.qeval = (() => {
        return Quick.qBoolEval(this.bool);
        })();
    }
}
export class Void {
    public kind: ASTKinds.Void = ASTKinds.Void;
    public evalfn: EvalFn;
    public qeval: Quick.EvalFn;
    constructor(){
        this.evalfn = (() => {
        return () => Promise.resolve(null);
        })();
        this.qeval = (() => {
        return () => null;
        })();
    }
}
export class Int {
    public kind: ASTKinds.Int = ASTKinds.Int;
    public int: string;
    public evalfn: EvalFn;
    public qeval: Quick.EvalFn;
    constructor(int: string){
        this.int = int;
        this.evalfn = (() => {
        return qEvalToEval(Quick.qIntEval(this.int));
        })();
        this.qeval = (() => {
        return Quick.qIntEval(this.int);
        })();
    }
}
export class Letters {
    public kind: ASTKinds.Letters = ASTKinds.Letters;
    public val: string;
    public evalfn: EvalFn;
    public qeval: Quick.EvalFn;
    constructor(val: string){
        this.val = val;
        this.evalfn = (() => {
        return qEvalToEval(Quick.qLettersEval(this.val));
        })();
        this.qeval = (() => {
        return Quick.qLettersEval(this.val);
        })();
    }
}
export type _ = wspace[];
export type wspace = string;
export type gap = gap_1 | gap_2;
export type gap_1 = gap_$0[];
export type gap_2 = string;
export type gap_$0 = gap_$0_1 | gap_$0_2;
export type gap_$0_1 = wspace;
export type gap_$0_2 = string;
export type PlusMinus = string;
export type AsgnOp = string;
export type MulDiv = string;
export type Compare = string;
export type Keyword = Keyword_1 | Keyword_2 | Keyword_3 | Keyword_4 | Keyword_5 | Keyword_6 | Keyword_7 | Keyword_8 | Keyword_9 | Keyword_10;
export type Keyword_1 = string;
export type Keyword_2 = string;
export type Keyword_3 = string;
export type Keyword_4 = string;
export type Keyword_5 = string;
export type Keyword_6 = string;
export type Keyword_7 = string;
export type Keyword_8 = string;
export type Keyword_9 = string;
export type Keyword_10 = string;
export class Parser {
    private readonly input: string;
    private pos: PosInfo;
    private negating: boolean = false;
    constructor(input: string) {
        this.pos = {overallPos: 0, line: 1, offset: 0};
        this.input = input;
    }
    public reset(pos: PosInfo) {
        this.pos = pos;
    }
    public finished(): boolean {
        return this.pos.overallPos === this.input.length;
    }
    public matchProgram($$dpth: number, cr?: ContextRecorder): Nullable<Program> {
        return this.runner<Program>($$dpth,
            (log) => {
                if (log) {
                    log("Program");
                }
                let stmts: Nullable<AsgnStmt[]>;
                let res: Nullable<Program> = null;
                if (true
                    && (stmts = this.loop<AsgnStmt>(() => this.matchAsgnStmt($$dpth + 1, cr), true)) !== null
                    && this.match_($$dpth + 1, cr) !== null
                ) {
                    res = {kind: ASTKinds.Program, stmts};
                }
                return res;
            }, cr)();
    }
    public matchAsgnStmt($$dpth: number, cr?: ContextRecorder): Nullable<AsgnStmt> {
        return this.choice<AsgnStmt>([
            () => this.matchAsgnStmt_1($$dpth + 1, cr),
            () => this.matchAsgnStmt_2($$dpth + 1, cr),
            () => this.matchAsgnStmt_3($$dpth + 1, cr),
            () => this.matchAsgnStmt_4($$dpth + 1, cr),
            () => this.matchAsgnStmt_5($$dpth + 1, cr),
            () => this.matchAsgnStmt_6($$dpth + 1, cr),
            () => this.matchAsgnStmt_7($$dpth + 1, cr),
            () => this.matchAsgnStmt_8($$dpth + 1, cr),
            () => this.matchAsgnStmt_9($$dpth + 1, cr),
            () => this.matchAsgnStmt_10($$dpth + 1, cr),
            () => this.matchAsgnStmt_11($$dpth + 1, cr),
            () => this.matchAsgnStmt_12($$dpth + 1, cr),
        ]);
    }
    public matchAsgnStmt_1($$dpth: number, cr?: ContextRecorder): Nullable<AsgnStmt_1> {
        return this.matchIfStmt($$dpth + 1, cr);
    }
    public matchAsgnStmt_2($$dpth: number, cr?: ContextRecorder): Nullable<AsgnStmt_2> {
        return this.matchBlockStmt($$dpth + 1, cr);
    }
    public matchAsgnStmt_3($$dpth: number, cr?: ContextRecorder): Nullable<AsgnStmt_3> {
        return this.matchWhenStmt($$dpth + 1, cr);
    }
    public matchAsgnStmt_4($$dpth: number, cr?: ContextRecorder): Nullable<AsgnStmt_4> {
        return this.matchForStmt($$dpth + 1, cr);
    }
    public matchAsgnStmt_5($$dpth: number, cr?: ContextRecorder): Nullable<AsgnStmt_5> {
        return this.matchContinueStmt($$dpth + 1, cr);
    }
    public matchAsgnStmt_6($$dpth: number, cr?: ContextRecorder): Nullable<AsgnStmt_6> {
        return this.matchBreakStmt($$dpth + 1, cr);
    }
    public matchAsgnStmt_7($$dpth: number, cr?: ContextRecorder): Nullable<AsgnStmt_7> {
        return this.matchCtlchStmt($$dpth + 1, cr);
    }
    public matchAsgnStmt_8($$dpth: number, cr?: ContextRecorder): Nullable<AsgnStmt_8> {
        return this.matchFunctionStmt($$dpth + 1, cr);
    }
    public matchAsgnStmt_9($$dpth: number, cr?: ContextRecorder): Nullable<AsgnStmt_9> {
        return this.matchReturnStmt($$dpth + 1, cr);
    }
    public matchAsgnStmt_10($$dpth: number, cr?: ContextRecorder): Nullable<AsgnStmt_10> {
        return this.matchAssignStmt($$dpth + 1, cr);
    }
    public matchAsgnStmt_11($$dpth: number, cr?: ContextRecorder): Nullable<AsgnStmt_11> {
        return this.matchDefnStmt($$dpth + 1, cr);
    }
    public matchAsgnStmt_12($$dpth: number, cr?: ContextRecorder): Nullable<AsgnStmt_12> {
        return this.matchExpr($$dpth + 1, cr);
    }
    public matchNonAsgnStmt($$dpth: number, cr?: ContextRecorder): Nullable<NonAsgnStmt> {
        return this.choice<NonAsgnStmt>([
            () => this.matchNonAsgnStmt_1($$dpth + 1, cr),
            () => this.matchNonAsgnStmt_2($$dpth + 1, cr),
            () => this.matchNonAsgnStmt_3($$dpth + 1, cr),
            () => this.matchNonAsgnStmt_4($$dpth + 1, cr),
            () => this.matchNonAsgnStmt_5($$dpth + 1, cr),
            () => this.matchNonAsgnStmt_6($$dpth + 1, cr),
            () => this.matchNonAsgnStmt_7($$dpth + 1, cr),
            () => this.matchNonAsgnStmt_8($$dpth + 1, cr),
            () => this.matchNonAsgnStmt_9($$dpth + 1, cr),
        ]);
    }
    public matchNonAsgnStmt_1($$dpth: number, cr?: ContextRecorder): Nullable<NonAsgnStmt_1> {
        return this.matchIfStmt($$dpth + 1, cr);
    }
    public matchNonAsgnStmt_2($$dpth: number, cr?: ContextRecorder): Nullable<NonAsgnStmt_2> {
        return this.matchWhenStmt($$dpth + 1, cr);
    }
    public matchNonAsgnStmt_3($$dpth: number, cr?: ContextRecorder): Nullable<NonAsgnStmt_3> {
        return this.matchForStmt($$dpth + 1, cr);
    }
    public matchNonAsgnStmt_4($$dpth: number, cr?: ContextRecorder): Nullable<NonAsgnStmt_4> {
        return this.matchContinueStmt($$dpth + 1, cr);
    }
    public matchNonAsgnStmt_5($$dpth: number, cr?: ContextRecorder): Nullable<NonAsgnStmt_5> {
        return this.matchBreakStmt($$dpth + 1, cr);
    }
    public matchNonAsgnStmt_6($$dpth: number, cr?: ContextRecorder): Nullable<NonAsgnStmt_6> {
        return this.matchReturnStmt($$dpth + 1, cr);
    }
    public matchNonAsgnStmt_7($$dpth: number, cr?: ContextRecorder): Nullable<NonAsgnStmt_7> {
        return this.matchBlockStmt($$dpth + 1, cr);
    }
    public matchNonAsgnStmt_8($$dpth: number, cr?: ContextRecorder): Nullable<NonAsgnStmt_8> {
        return this.matchAssignStmt($$dpth + 1, cr);
    }
    public matchNonAsgnStmt_9($$dpth: number, cr?: ContextRecorder): Nullable<NonAsgnStmt_9> {
        return this.matchExpr($$dpth + 1, cr);
    }
    public matchIfStmt($$dpth: number, cr?: ContextRecorder): Nullable<IfStmt> {
        return this.runner<IfStmt>($$dpth,
            (log) => {
                if (log) {
                    log("IfStmt");
                }
                let expr: Nullable<Expr>;
                let stmt: Nullable<NonAsgnStmt>;
                let elsebranch: Nullable<Nullable<IfStmt_$0>>;
                let res: Nullable<IfStmt> = null;
                if (true
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`if`, $$dpth + 1, cr) !== null
                    && this.noConsume<gap>(() => this.matchgap($$dpth + 1, cr)) !== null
                    && (expr = this.matchExpr($$dpth + 1, cr)) !== null
                    && this.noConsume<gap>(() => this.matchgap($$dpth + 1, cr)) !== null
                    && (stmt = this.matchNonAsgnStmt($$dpth + 1, cr)) !== null
                    && ((elsebranch = this.matchIfStmt_$0($$dpth + 1, cr)) || true)
                ) {
                    res = {kind: ASTKinds.IfStmt, expr, stmt, elsebranch};
                }
                return res;
            }, cr)();
    }
    public matchIfStmt_$0($$dpth: number, cr?: ContextRecorder): Nullable<IfStmt_$0> {
        return this.runner<IfStmt_$0>($$dpth,
            (log) => {
                if (log) {
                    log("IfStmt_$0");
                }
                let stmt: Nullable<NonAsgnStmt>;
                let res: Nullable<IfStmt_$0> = null;
                if (true
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`or`, $$dpth + 1, cr) !== null
                    && this.noConsume<gap>(() => this.matchgap($$dpth + 1, cr)) !== null
                    && (stmt = this.matchNonAsgnStmt($$dpth + 1, cr)) !== null
                ) {
                    res = {kind: ASTKinds.IfStmt_$0, stmt};
                }
                return res;
            }, cr)();
    }
    public matchBlockStmt($$dpth: number, cr?: ContextRecorder): Nullable<BlockStmt> {
        return this.runner<BlockStmt>($$dpth,
            (log) => {
                if (log) {
                    log("BlockStmt");
                }
                let blk: Nullable<AsgnStmt[]>;
                let res: Nullable<BlockStmt> = null;
                if (true
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`{`, $$dpth + 1, cr) !== null
                    && (blk = this.loop<AsgnStmt>(() => this.matchAsgnStmt($$dpth + 1, cr), true)) !== null
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`}`, $$dpth + 1, cr) !== null
                ) {
                    res = {kind: ASTKinds.BlockStmt, blk};
                }
                return res;
            }, cr)();
    }
    public matchWhenStmt($$dpth: number, cr?: ContextRecorder): Nullable<WhenStmt> {
        return this.runner<WhenStmt>($$dpth,
            (log) => {
                if (log) {
                    log("WhenStmt");
                }
                let expr: Nullable<Expr>;
                let stmt: Nullable<NonAsgnStmt>;
                let res: Nullable<WhenStmt> = null;
                if (true
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`when`, $$dpth + 1, cr) !== null
                    && (expr = this.matchExpr($$dpth + 1, cr)) !== null
                    && this.noConsume<gap>(() => this.matchgap($$dpth + 1, cr)) !== null
                    && (stmt = this.matchNonAsgnStmt($$dpth + 1, cr)) !== null
                ) {
                    res = {kind: ASTKinds.WhenStmt, expr, stmt};
                }
                return res;
            }, cr)();
    }
    public matchForStmt($$dpth: number, cr?: ContextRecorder): Nullable<ForStmt> {
        return this.runner<ForStmt>($$dpth,
            (log) => {
                if (log) {
                    log("ForStmt");
                }
                let id: Nullable<ID>;
                let strt: Nullable<Expr>;
                let end: Nullable<Expr>;
                let step: Nullable<Nullable<ForStmt_$0>>;
                let stmt: Nullable<NonAsgnStmt>;
                let res: Nullable<ForStmt> = null;
                if (true
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`for`, $$dpth + 1, cr) !== null
                    && this.noConsume<gap>(() => this.matchgap($$dpth + 1, cr)) !== null
                    && (id = this.matchID($$dpth + 1, cr)) !== null
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`in`, $$dpth + 1, cr) !== null
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`\(`, $$dpth + 1, cr) !== null
                    && (strt = this.matchExpr($$dpth + 1, cr)) !== null
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`,`, $$dpth + 1, cr) !== null
                    && (end = this.matchExpr($$dpth + 1, cr)) !== null
                    && ((step = this.matchForStmt_$0($$dpth + 1, cr)) || true)
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`\)`, $$dpth + 1, cr) !== null
                    && (stmt = this.matchNonAsgnStmt($$dpth + 1, cr)) !== null
                ) {
                    res = {kind: ASTKinds.ForStmt, id, strt, end, step, stmt};
                }
                return res;
            }, cr)();
    }
    public matchForStmt_$0($$dpth: number, cr?: ContextRecorder): Nullable<ForStmt_$0> {
        return this.runner<ForStmt_$0>($$dpth,
            (log) => {
                if (log) {
                    log("ForStmt_$0");
                }
                let step: Nullable<Expr>;
                let res: Nullable<ForStmt_$0> = null;
                if (true
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`,`, $$dpth + 1, cr) !== null
                    && (step = this.matchExpr($$dpth + 1, cr)) !== null
                ) {
                    res = {kind: ASTKinds.ForStmt_$0, step};
                }
                return res;
            }, cr)();
    }
    public matchDefnStmt($$dpth: number, cr?: ContextRecorder): Nullable<DefnStmt> {
        return this.runner<DefnStmt>($$dpth,
            (log) => {
                if (log) {
                    log("DefnStmt");
                }
                let idstart: Nullable<PosInfo>;
                let id: Nullable<ID>;
                let idend: Nullable<PosInfo>;
                let expr: Nullable<Expr>;
                let res: Nullable<DefnStmt> = null;
                if (true
                    && this.match_($$dpth + 1, cr) !== null
                    && (idstart = this.mark()) !== null
                    && (id = this.matchID($$dpth + 1, cr)) !== null
                    && (idend = this.mark()) !== null
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`:=`, $$dpth + 1, cr) !== null
                    && this.match_($$dpth + 1, cr) !== null
                    && (expr = this.matchExpr($$dpth + 1, cr)) !== null
                ) {
                    res = {kind: ASTKinds.DefnStmt, idstart, id, idend, expr};
                }
                return res;
            }, cr)();
    }
    public matchAssignStmt($$dpth: number, cr?: ContextRecorder): Nullable<AssignStmt> {
        return this.runner<AssignStmt>($$dpth,
            (log) => {
                if (log) {
                    log("AssignStmt");
                }
                let lhs: Nullable<Postfix>;
                let op: Nullable<AsgnOp>;
                let expr: Nullable<Expr>;
                let res: Nullable<AssignStmt> = null;
                if (true
                    && this.match_($$dpth + 1, cr) !== null
                    && (lhs = this.matchPostfix($$dpth + 1, cr)) !== null
                    && this.match_($$dpth + 1, cr) !== null
                    && (op = this.matchAsgnOp($$dpth + 1, cr)) !== null
                    && this.match_($$dpth + 1, cr) !== null
                    && (expr = this.matchExpr($$dpth + 1, cr)) !== null
                ) {
                    res = {kind: ASTKinds.AssignStmt, lhs, op, expr};
                }
                return res;
            }, cr)();
    }
    public matchFunctionStmt($$dpth: number, cr?: ContextRecorder): Nullable<FunctionStmt> {
        return this.runner<FunctionStmt>($$dpth,
            (log) => {
                if (log) {
                    log("FunctionStmt");
                }
                let id: Nullable<ID>;
                let args: Nullable<Nullable<CSIDs>>;
                let stmts: Nullable<AsgnStmt[]>;
                let res: Nullable<FunctionStmt> = null;
                if (true
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`function`, $$dpth + 1, cr) !== null
                    && this.noConsume<gap>(() => this.matchgap($$dpth + 1, cr)) !== null
                    && (id = this.matchID($$dpth + 1, cr)) !== null
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`\(`, $$dpth + 1, cr) !== null
                    && ((args = this.matchCSIDs($$dpth + 1, cr)) || true)
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`\)`, $$dpth + 1, cr) !== null
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`{`, $$dpth + 1, cr) !== null
                    && (stmts = this.loop<AsgnStmt>(() => this.matchAsgnStmt($$dpth + 1, cr), true)) !== null
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`}`, $$dpth + 1, cr) !== null
                ) {
                    res = {kind: ASTKinds.FunctionStmt, id, args, stmts};
                }
                return res;
            }, cr)();
    }
    public matchCtlchStmt($$dpth: number, cr?: ContextRecorder): Nullable<CtlchStmt> {
        return this.runner<CtlchStmt>($$dpth,
            (log) => {
                if (log) {
                    log("CtlchStmt");
                }
                let id: Nullable<ID>;
                let tuis: Nullable<Nullable<CtlchStmt_$0>>;
                let functions: Nullable<FunctionStmt[]>;
                let res: Nullable<CtlchStmt> = null;
                if (true
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`object`, $$dpth + 1, cr) !== null
                    && this.noConsume<gap>(() => this.matchgap($$dpth + 1, cr)) !== null
                    && (id = this.matchID($$dpth + 1, cr)) !== null
                    && ((tuis = this.matchCtlchStmt_$0($$dpth + 1, cr)) || true)
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`{`, $$dpth + 1, cr) !== null
                    && (functions = this.loop<FunctionStmt>(() => this.matchFunctionStmt($$dpth + 1, cr), true)) !== null
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`}`, $$dpth + 1, cr) !== null
                ) {
                    res = {kind: ASTKinds.CtlchStmt, id, tuis, functions};
                }
                return res;
            }, cr)();
    }
    public matchCtlchStmt_$0($$dpth: number, cr?: ContextRecorder): Nullable<CtlchStmt_$0> {
        return this.runner<CtlchStmt_$0>($$dpth,
            (log) => {
                if (log) {
                    log("CtlchStmt_$0");
                }
                let parentstart: Nullable<PosInfo>;
                let id: Nullable<ID>;
                let parentend: Nullable<PosInfo>;
                let res: Nullable<CtlchStmt_$0> = null;
                if (true
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`รณ`, $$dpth + 1, cr) !== null
                    && this.noConsume<gap>(() => this.matchgap($$dpth + 1, cr)) !== null
                    && (parentstart = this.mark()) !== null
                    && (id = this.matchID($$dpth + 1, cr)) !== null
                    && (parentend = this.mark()) !== null
                ) {
                    res = {kind: ASTKinds.CtlchStmt_$0, parentstart, id, parentend};
                }
                return res;
            }, cr)();
    }
    public matchBreakStmt($$dpth: number, cr?: ContextRecorder): Nullable<BreakStmt> {
        return this.runner<BreakStmt>($$dpth,
            (log) => {
                if (log) {
                    log("BreakStmt");
                }
                let res: Nullable<BreakStmt> = null;
                if (true
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`break`, $$dpth + 1, cr) !== null
                ) {
                    res = {kind: ASTKinds.BreakStmt, };
                }
                return res;
            }, cr)();
    }
    public matchContinueStmt($$dpth: number, cr?: ContextRecorder): Nullable<ContinueStmt> {
        return this.runner<ContinueStmt>($$dpth,
            (log) => {
                if (log) {
                    log("ContinueStmt");
                }
                let res: Nullable<ContinueStmt> = null;
                if (true
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`continue`, $$dpth + 1, cr) !== null
                ) {
                    res = {kind: ASTKinds.ContinueStmt, };
                }
                return res;
            }, cr)();
    }
    public matchReturnStmt($$dpth: number, cr?: ContextRecorder): Nullable<ReturnStmt> {
        return this.runner<ReturnStmt>($$dpth,
            (log) => {
                if (log) {
                    log("ReturnStmt");
                }
                let exp: Nullable<Nullable<Expr>>;
                let res: Nullable<ReturnStmt> = null;
                if (true
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`return`, $$dpth + 1, cr) !== null
                    && this.noConsume<gap>(() => this.matchgap($$dpth + 1, cr)) !== null
                    && ((exp = this.matchExpr($$dpth + 1, cr)) || true)
                ) {
                    res = {kind: ASTKinds.ReturnStmt, exp};
                }
                return res;
            }, cr)();
    }
    public matchExpr($$dpth: number, cr?: ContextRecorder): Nullable<Expr> {
        return this.matchAnd($$dpth + 1, cr);
    }
    public matchAnd($$dpth: number, cr?: ContextRecorder): Nullable<And> {
        return this.runner<And>($$dpth,
            (log) => {
                if (log) {
                    log("And");
                }
                let start: Nullable<PosInfo>;
                let head: Nullable<Or>;
                let tail: Nullable<And_$0[]>;
                let end: Nullable<PosInfo>;
                let res: Nullable<And> = null;
                if (true
                    && (start = this.mark()) !== null
                    && (head = this.matchOr($$dpth + 1, cr)) !== null
                    && (tail = this.loop<And_$0>(() => this.matchAnd_$0($$dpth + 1, cr), true)) !== null
                    && (end = this.mark()) !== null
                ) {
                    res = new And(start, head, tail, end);
                }
                return res;
            }, cr)();
    }
    public matchAnd_$0($$dpth: number, cr?: ContextRecorder): Nullable<And_$0> {
        return this.runner<And_$0>($$dpth,
            (log) => {
                if (log) {
                    log("And_$0");
                }
                let trm: Nullable<Or>;
                let res: Nullable<And_$0> = null;
                if (true
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`\&`, $$dpth + 1, cr) !== null
                    && (trm = this.matchOr($$dpth + 1, cr)) !== null
                ) {
                    res = {kind: ASTKinds.And_$0, trm};
                }
                return res;
            }, cr)();
    }
    public matchOr($$dpth: number, cr?: ContextRecorder): Nullable<Or> {
        return this.runner<Or>($$dpth,
            (log) => {
                if (log) {
                    log("Or");
                }
                let start: Nullable<PosInfo>;
                let head: Nullable<Eq>;
                let tail: Nullable<Or_$0[]>;
                let end: Nullable<PosInfo>;
                let res: Nullable<Or> = null;
                if (true
                    && (start = this.mark()) !== null
                    && (head = this.matchEq($$dpth + 1, cr)) !== null
                    && (tail = this.loop<Or_$0>(() => this.matchOr_$0($$dpth + 1, cr), true)) !== null
                    && (end = this.mark()) !== null
                ) {
                    res = new Or(start, head, tail, end);
                }
                return res;
            }, cr)();
    }
    public matchOr_$0($$dpth: number, cr?: ContextRecorder): Nullable<Or_$0> {
        return this.runner<Or_$0>($$dpth,
            (log) => {
                if (log) {
                    log("Or_$0");
                }
                let trm: Nullable<Eq>;
                let res: Nullable<Or_$0> = null;
                if (true
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`\|`, $$dpth + 1, cr) !== null
                    && (trm = this.matchEq($$dpth + 1, cr)) !== null
                ) {
                    res = {kind: ASTKinds.Or_$0, trm};
                }
                return res;
            }, cr)();
    }
    public matchEq($$dpth: number, cr?: ContextRecorder): Nullable<Eq> {
        return this.runner<Eq>($$dpth,
            (log) => {
                if (log) {
                    log("Eq");
                }
                let start: Nullable<PosInfo>;
                let head: Nullable<Comp>;
                let tail: Nullable<Eq_$0[]>;
                let end: Nullable<PosInfo>;
                let res: Nullable<Eq> = null;
                if (true
                    && (start = this.mark()) !== null
                    && (head = this.matchComp($$dpth + 1, cr)) !== null
                    && (tail = this.loop<Eq_$0>(() => this.matchEq_$0($$dpth + 1, cr), true)) !== null
                    && (end = this.mark()) !== null
                ) {
                    res = new Eq(start, head, tail, end);
                }
                return res;
            }, cr)();
    }
    public matchEq_$0($$dpth: number, cr?: ContextRecorder): Nullable<Eq_$0> {
        return this.runner<Eq_$0>($$dpth,
            (log) => {
                if (log) {
                    log("Eq_$0");
                }
                let op: Nullable<string>;
                let trm: Nullable<Comp>;
                let res: Nullable<Eq_$0> = null;
                if (true
                    && this.match_($$dpth + 1, cr) !== null
                    && (op = this.regexAccept(String.raw`[!=]=`, $$dpth + 1, cr)) !== null
                    && (trm = this.matchComp($$dpth + 1, cr)) !== null
                ) {
                    res = {kind: ASTKinds.Eq_$0, op, trm};
                }
                return res;
            }, cr)();
    }
    public matchComp($$dpth: number, cr?: ContextRecorder): Nullable<Comp> {
        return this.runner<Comp>($$dpth,
            (log) => {
                if (log) {
                    log("Comp");
                }
                let start: Nullable<PosInfo>;
                let head: Nullable<Sum>;
                let tail: Nullable<Comp_$0[]>;
                let end: Nullable<PosInfo>;
                let res: Nullable<Comp> = null;
                if (true
                    && (start = this.mark()) !== null
                    && (head = this.matchSum($$dpth + 1, cr)) !== null
                    && (tail = this.loop<Comp_$0>(() => this.matchComp_$0($$dpth + 1, cr), true)) !== null
                    && (end = this.mark()) !== null
                ) {
                    res = new Comp(start, head, tail, end);
                }
                return res;
            }, cr)();
    }
    public matchComp_$0($$dpth: number, cr?: ContextRecorder): Nullable<Comp_$0> {
        return this.runner<Comp_$0>($$dpth,
            (log) => {
                if (log) {
                    log("Comp_$0");
                }
                let op: Nullable<Compare>;
                let trm: Nullable<Sum>;
                let res: Nullable<Comp_$0> = null;
                if (true
                    && this.match_($$dpth + 1, cr) !== null
                    && (op = this.matchCompare($$dpth + 1, cr)) !== null
                    && (trm = this.matchSum($$dpth + 1, cr)) !== null
                ) {
                    res = {kind: ASTKinds.Comp_$0, op, trm};
                }
                return res;
            }, cr)();
    }
    public matchSum($$dpth: number, cr?: ContextRecorder): Nullable<Sum> {
        return this.runner<Sum>($$dpth,
            (log) => {
                if (log) {
                    log("Sum");
                }
                let start: Nullable<PosInfo>;
                let head: Nullable<Product>;
                let tail: Nullable<Sum_$0[]>;
                let end: Nullable<PosInfo>;
                let res: Nullable<Sum> = null;
                if (true
                    && (start = this.mark()) !== null
                    && (head = this.matchProduct($$dpth + 1, cr)) !== null
                    && (tail = this.loop<Sum_$0>(() => this.matchSum_$0($$dpth + 1, cr), true)) !== null
                    && (end = this.mark()) !== null
                ) {
                    res = new Sum(start, head, tail, end);
                }
                return res;
            }, cr)();
    }
    public matchSum_$0($$dpth: number, cr?: ContextRecorder): Nullable<Sum_$0> {
        return this.runner<Sum_$0>($$dpth,
            (log) => {
                if (log) {
                    log("Sum_$0");
                }
                let op: Nullable<PlusMinus>;
                let trm: Nullable<Product>;
                let res: Nullable<Sum_$0> = null;
                if (true
                    && this.match_($$dpth + 1, cr) !== null
                    && (op = this.matchPlusMinus($$dpth + 1, cr)) !== null
                    && (trm = this.matchProduct($$dpth + 1, cr)) !== null
                ) {
                    res = {kind: ASTKinds.Sum_$0, op, trm};
                }
                return res;
            }, cr)();
    }
    public matchProduct($$dpth: number, cr?: ContextRecorder): Nullable<Product> {
        return this.runner<Product>($$dpth,
            (log) => {
                if (log) {
                    log("Product");
                }
                let start: Nullable<PosInfo>;
                let head: Nullable<Prefix>;
                let tail: Nullable<Product_$0[]>;
                let end: Nullable<PosInfo>;
                let res: Nullable<Product> = null;
                if (true
                    && (start = this.mark()) !== null
                    && (head = this.matchPrefix($$dpth + 1, cr)) !== null
                    && (tail = this.loop<Product_$0>(() => this.matchProduct_$0($$dpth + 1, cr), true)) !== null
                    && (end = this.mark()) !== null
                ) {
                    res = new Product(start, head, tail, end);
                }
                return res;
            }, cr)();
    }
    public matchProduct_$0($$dpth: number, cr?: ContextRecorder): Nullable<Product_$0> {
        return this.runner<Product_$0>($$dpth,
            (log) => {
                if (log) {
                    log("Product_$0");
                }
                let op: Nullable<MulDiv>;
                let trm: Nullable<Prefix>;
                let res: Nullable<Product_$0> = null;
                if (true
                    && this.match_($$dpth + 1, cr) !== null
                    && (op = this.matchMulDiv($$dpth + 1, cr)) !== null
                    && (trm = this.matchPrefix($$dpth + 1, cr)) !== null
                ) {
                    res = {kind: ASTKinds.Product_$0, op, trm};
                }
                return res;
            }, cr)();
    }
    public matchPrefix($$dpth: number, cr?: ContextRecorder): Nullable<Prefix> {
        return this.runner<Prefix>($$dpth,
            (log) => {
                if (log) {
                    log("Prefix");
                }
                let start: Nullable<PosInfo>;
                let op: Nullable<Nullable<string>>;
                let pf: Nullable<Postfix>;
                let end: Nullable<PosInfo>;
                let res: Nullable<Prefix> = null;
                if (true
                    && this.match_($$dpth + 1, cr) !== null
                    && (start = this.mark()) !== null
                    && ((op = this.regexAccept(String.raw`-|!`, $$dpth + 1, cr)) || true)
                    && (pf = this.matchPostfix($$dpth + 1, cr)) !== null
                    && (end = this.mark()) !== null
                ) {
                    res = new Prefix(start, op, pf, end);
                }
                return res;
            }, cr)();
    }
    public matchPostfix($$dpth: number, cr?: ContextRecorder): Nullable<Postfix> {
        return this.runner<Postfix>($$dpth,
            (log) => {
                if (log) {
                    log("Postfix");
                }
                let start: Nullable<PosInfo>;
                let at: Nullable<ObjLookups>;
                let ops: Nullable<PostOp[]>;
                let end: Nullable<PosInfo>;
                let res: Nullable<Postfix> = null;
                if (true
                    && (start = this.mark()) !== null
                    && (at = this.matchObjLookups($$dpth + 1, cr)) !== null
                    && (ops = this.loop<PostOp>(() => this.matchPostOp($$dpth + 1, cr), true)) !== null
                    && (end = this.mark()) !== null
                ) {
                    res = new Postfix(start, at, ops, end);
                }
                return res;
            }, cr)();
    }
    public matchObjLookups($$dpth: number, cr?: ContextRecorder): Nullable<ObjLookups> {
        return this.runner<ObjLookups>($$dpth,
            (log) => {
                if (log) {
                    log("ObjLookups");
                }
                let start: Nullable<PosInfo>;
                let attrs: Nullable<ObjLookups_$0[]>;
                let root: Nullable<Atom>;
                let end: Nullable<PosInfo>;
                let res: Nullable<ObjLookups> = null;
                if (true
                    && (start = this.mark()) !== null
                    && (attrs = this.loop<ObjLookups_$0>(() => this.matchObjLookups_$0($$dpth + 1, cr), true)) !== null
                    && (root = this.matchAtom($$dpth + 1, cr)) !== null
                    && (end = this.mark()) !== null
                ) {
                    res = new ObjLookups(start, attrs, root, end);
                }
                return res;
            }, cr)();
    }
    public matchObjLookups_$0($$dpth: number, cr?: ContextRecorder): Nullable<ObjLookups_$0> {
        return this.runner<ObjLookups_$0>($$dpth,
            (log) => {
                if (log) {
                    log("ObjLookups_$0");
                }
                let id: Nullable<ID>;
                let res: Nullable<ObjLookups_$0> = null;
                if (true
                    && (id = this.matchID($$dpth + 1, cr)) !== null
                    && this.regexAccept(String.raw`@`, $$dpth + 1, cr) !== null
                    && this.negate(() => this.matchwspace($$dpth + 1, cr)) !== null
                ) {
                    res = {kind: ASTKinds.ObjLookups_$0, id};
                }
                return res;
            }, cr)();
    }
    public matchPostOp($$dpth: number, cr?: ContextRecorder): Nullable<PostOp> {
        return this.choice<PostOp>([
            () => this.matchPostOp_1($$dpth + 1, cr),
            () => this.matchPostOp_2($$dpth + 1, cr),
        ]);
    }
    public matchPostOp_1($$dpth: number, cr?: ContextRecorder): Nullable<PostOp_1> {
        return this.runner<PostOp_1>($$dpth,
            (log) => {
                if (log) {
                    log("PostOp_1");
                }
                let args: Nullable<Nullable<CSArgs>>;
                let res: Nullable<PostOp_1> = null;
                if (true
                    && this.regexAccept(String.raw`\(`, $$dpth + 1, cr) !== null
                    && ((args = this.matchCSArgs($$dpth + 1, cr)) || true)
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`\)`, $$dpth + 1, cr) !== null
                ) {
                    res = {kind: ASTKinds.PostOp_1, args};
                }
                return res;
            }, cr)();
    }
    public matchPostOp_2($$dpth: number, cr?: ContextRecorder): Nullable<PostOp_2> {
        return this.runner<PostOp_2>($$dpth,
            (log) => {
                if (log) {
                    log("PostOp_2");
                }
                let expr: Nullable<Expr>;
                let res: Nullable<PostOp_2> = null;
                if (true
                    && this.regexAccept(String.raw`\[`, $$dpth + 1, cr) !== null
                    && (expr = this.matchExpr($$dpth + 1, cr)) !== null
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`\]`, $$dpth + 1, cr) !== null
                ) {
                    res = {kind: ASTKinds.PostOp_2, expr};
                }
                return res;
            }, cr)();
    }
    public matchAtom($$dpth: number, cr?: ContextRecorder): Nullable<Atom> {
        return this.choice<Atom>([
            () => this.matchAtom_1($$dpth + 1, cr),
            () => this.matchAtom_2($$dpth + 1, cr),
            () => this.matchAtom_3($$dpth + 1, cr),
            () => this.matchAtom_4($$dpth + 1, cr),
            () => this.matchAtom_5($$dpth + 1, cr),
            () => this.matchAtom_6($$dpth + 1, cr),
            () => this.matchAtom_7($$dpth + 1, cr),
        ]);
    }
    public matchAtom_1($$dpth: number, cr?: ContextRecorder): Nullable<Atom_1> {
        return this.runner<Atom_1>($$dpth,
            (log) => {
                if (log) {
                    log("Atom_1");
                }
                let trm: Nullable<Expr>;
                let res: Nullable<Atom_1> = null;
                if (true
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`\(`, $$dpth + 1, cr) !== null
                    && (trm = this.matchExpr($$dpth + 1, cr)) !== null
                    && this.regexAccept(String.raw`\)`, $$dpth + 1, cr) !== null
                ) {
                    res = new Atom_1(trm);
                }
                return res;
            }, cr)();
    }
    public matchAtom_2($$dpth: number, cr?: ContextRecorder): Nullable<Atom_2> {
        return this.matchID($$dpth + 1, cr);
    }
    public matchAtom_3($$dpth: number, cr?: ContextRecorder): Nullable<Atom_3> {
        return this.matchLetters($$dpth + 1, cr);
    }
    public matchAtom_4($$dpth: number, cr?: ContextRecorder): Nullable<Atom_4> {
        return this.matchInt($$dpth + 1, cr);
    }
    public matchAtom_5($$dpth: number, cr?: ContextRecorder): Nullable<Atom_5> {
        return this.matchBool($$dpth + 1, cr);
    }
    public matchAtom_6($$dpth: number, cr?: ContextRecorder): Nullable<Atom_6> {
        return this.matchVoid($$dpth + 1, cr);
    }
    public matchAtom_7($$dpth: number, cr?: ContextRecorder): Nullable<Atom_7> {
        return this.matchListLit($$dpth + 1, cr);
    }
    public matchListLit($$dpth: number, cr?: ContextRecorder): Nullable<ListLit> {
        return this.runner<ListLit>($$dpth,
            (log) => {
                if (log) {
                    log("ListLit");
                }
                let els: Nullable<Nullable<CSArgs>>;
                let res: Nullable<ListLit> = null;
                if (true
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`\[`, $$dpth + 1, cr) !== null
                    && ((els = this.matchCSArgs($$dpth + 1, cr)) || true)
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`\]`, $$dpth + 1, cr) !== null
                ) {
                    res = new ListLit(els);
                }
                return res;
            }, cr)();
    }
    public matchCSArgs($$dpth: number, cr?: ContextRecorder): Nullable<CSArgs> {
        return this.runner<CSArgs>($$dpth,
            (log) => {
                if (log) {
                    log("CSArgs");
                }
                let start: Nullable<PosInfo>;
                let head: Nullable<Expr>;
                let tail: Nullable<CSArgs_$0[]>;
                let end: Nullable<PosInfo>;
                let res: Nullable<CSArgs> = null;
                if (true
                    && (start = this.mark()) !== null
                    && (head = this.matchExpr($$dpth + 1, cr)) !== null
                    && (tail = this.loop<CSArgs_$0>(() => this.matchCSArgs_$0($$dpth + 1, cr), true)) !== null
                    && (end = this.mark()) !== null
                ) {
                    res = new CSArgs(start, head, tail, end);
                }
                return res;
            }, cr)();
    }
    public matchCSArgs_$0($$dpth: number, cr?: ContextRecorder): Nullable<CSArgs_$0> {
        return this.runner<CSArgs_$0>($$dpth,
            (log) => {
                if (log) {
                    log("CSArgs_$0");
                }
                let exp: Nullable<Expr>;
                let res: Nullable<CSArgs_$0> = null;
                if (true
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`,`, $$dpth + 1, cr) !== null
                    && (exp = this.matchExpr($$dpth + 1, cr)) !== null
                ) {
                    res = {kind: ASTKinds.CSArgs_$0, exp};
                }
                return res;
            }, cr)();
    }
    public matchCSIDs($$dpth: number, cr?: ContextRecorder): Nullable<CSIDs> {
        return this.runner<CSIDs>($$dpth,
            (log) => {
                if (log) {
                    log("CSIDs");
                }
                let head: Nullable<ID>;
                let tail: Nullable<CSIDs_$0[]>;
                let res: Nullable<CSIDs> = null;
                if (true
                    && (head = this.matchID($$dpth + 1, cr)) !== null
                    && (tail = this.loop<CSIDs_$0>(() => this.matchCSIDs_$0($$dpth + 1, cr), true)) !== null
                ) {
                    res = {kind: ASTKinds.CSIDs, head, tail};
                }
                return res;
            }, cr)();
    }
    public matchCSIDs_$0($$dpth: number, cr?: ContextRecorder): Nullable<CSIDs_$0> {
        return this.runner<CSIDs_$0>($$dpth,
            (log) => {
                if (log) {
                    log("CSIDs_$0");
                }
                let id: Nullable<ID>;
                let res: Nullable<CSIDs_$0> = null;
                if (true
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`,`, $$dpth + 1, cr) !== null
                    && (id = this.matchID($$dpth + 1, cr)) !== null
                ) {
                    res = {kind: ASTKinds.CSIDs_$0, id};
                }
                return res;
            }, cr)();
    }
    public matchID($$dpth: number, cr?: ContextRecorder): Nullable<ID> {
        return this.runner<ID>($$dpth,
            (log) => {
                if (log) {
                    log("ID");
                }
                let start: Nullable<PosInfo>;
                let id: Nullable<string>;
                let end: Nullable<PosInfo>;
                let res: Nullable<ID> = null;
                if (true
                    && this.match_($$dpth + 1, cr) !== null
                    && this.negate(() => this.matchID_$0($$dpth + 1, cr)) !== null
                    && (start = this.mark()) !== null
                    && (id = this.regexAccept(String.raw`[a-zA-Z_]+`, $$dpth + 1, cr)) !== null
                    && (end = this.mark()) !== null
                ) {
                    res = new ID(start, id, end);
                }
                return res;
            }, cr)();
    }
    public matchID_$0($$dpth: number, cr?: ContextRecorder): Nullable<ID_$0> {
        return this.runner<ID_$0>($$dpth,
            (log) => {
                if (log) {
                    log("ID_$0");
                }
                let res: Nullable<ID_$0> = null;
                if (true
                    && this.matchKeyword($$dpth + 1, cr) !== null
                    && this.matchgap($$dpth + 1, cr) !== null
                ) {
                    res = {kind: ASTKinds.ID_$0, };
                }
                return res;
            }, cr)();
    }
    public matchBool($$dpth: number, cr?: ContextRecorder): Nullable<Bool> {
        return this.runner<Bool>($$dpth,
            (log) => {
                if (log) {
                    log("Bool");
                }
                let bool: Nullable<string>;
                let res: Nullable<Bool> = null;
                if (true
                    && this.match_($$dpth + 1, cr) !== null
                    && (bool = this.regexAccept(String.raw`true|false`, $$dpth + 1, cr)) !== null
                ) {
                    res = new Bool(bool);
                }
                return res;
            }, cr)();
    }
    public matchVoid($$dpth: number, cr?: ContextRecorder): Nullable<Void> {
        return this.runner<Void>($$dpth,
            (log) => {
                if (log) {
                    log("Void");
                }
                let res: Nullable<Void> = null;
                if (true
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`void`, $$dpth + 1, cr) !== null
                ) {
                    res = new Void();
                }
                return res;
            }, cr)();
    }
    public matchInt($$dpth: number, cr?: ContextRecorder): Nullable<Int> {
        return this.runner<Int>($$dpth,
            (log) => {
                if (log) {
                    log("Int");
                }
                let int: Nullable<string>;
                let res: Nullable<Int> = null;
                if (true
                    && this.match_($$dpth + 1, cr) !== null
                    && (int = this.regexAccept(String.raw`-?[0-9]+(?:\.[0-9]+)?`, $$dpth + 1, cr)) !== null
                ) {
                    res = new Int(int);
                }
                return res;
            }, cr)();
    }
    public matchLetters($$dpth: number, cr?: ContextRecorder): Nullable<Letters> {
        return this.runner<Letters>($$dpth,
            (log) => {
                if (log) {
                    log("Letters");
                }
                let val: Nullable<string>;
                let res: Nullable<Letters> = null;
                if (true
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`\'`, $$dpth + 1, cr) !== null
                    && (val = this.regexAccept(String.raw`([^\'\\]|\\.)*`, $$dpth + 1, cr)) !== null
                    && this.regexAccept(String.raw`\'`, $$dpth + 1, cr) !== null
                ) {
                    res = new Letters(val);
                }
                return res;
            }, cr)();
    }
    public match_($$dpth: number, cr?: ContextRecorder): Nullable<_> {
        return this.loop<wspace>(() => this.matchwspace($$dpth + 1, cr), true);
    }
    public matchwspace($$dpth: number, cr?: ContextRecorder): Nullable<wspace> {
        return this.regexAccept(String.raw`(?:\s|>--(?:(?!--<).)*(--<|\n|$))`, $$dpth + 1, cr);
    }
    public matchgap($$dpth: number, cr?: ContextRecorder): Nullable<gap> {
        return this.choice<gap>([
            () => this.matchgap_1($$dpth + 1, cr),
            () => this.matchgap_2($$dpth + 1, cr),
        ]);
    }
    public matchgap_1($$dpth: number, cr?: ContextRecorder): Nullable<gap_1> {
        return this.loop<gap_$0>(() => this.matchgap_$0($$dpth + 1, cr), false);
    }
    public matchgap_2($$dpth: number, cr?: ContextRecorder): Nullable<gap_2> {
        return this.regexAccept(String.raw`$`, $$dpth + 1, cr);
    }
    public matchgap_$0($$dpth: number, cr?: ContextRecorder): Nullable<gap_$0> {
        return this.choice<gap_$0>([
            () => this.matchgap_$0_1($$dpth + 1, cr),
            () => this.matchgap_$0_2($$dpth + 1, cr),
        ]);
    }
    public matchgap_$0_1($$dpth: number, cr?: ContextRecorder): Nullable<gap_$0_1> {
        return this.matchwspace($$dpth + 1, cr);
    }
    public matchgap_$0_2($$dpth: number, cr?: ContextRecorder): Nullable<gap_$0_2> {
        return this.regexAccept(String.raw`[^a-zA-Z0-9]`, $$dpth + 1, cr);
    }
    public matchPlusMinus($$dpth: number, cr?: ContextRecorder): Nullable<PlusMinus> {
        return this.regexAccept(String.raw`\+|-`, $$dpth + 1, cr);
    }
    public matchAsgnOp($$dpth: number, cr?: ContextRecorder): Nullable<AsgnOp> {
        return this.regexAccept(String.raw`=|\+=|\*=|-=|%=|\/=`, $$dpth + 1, cr);
    }
    public matchMulDiv($$dpth: number, cr?: ContextRecorder): Nullable<MulDiv> {
        return this.regexAccept(String.raw`\*|\/\/|%|\/`, $$dpth + 1, cr);
    }
    public matchCompare($$dpth: number, cr?: ContextRecorder): Nullable<Compare> {
        return this.regexAccept(String.raw`<=|>=|<|>`, $$dpth + 1, cr);
    }
    public matchKeyword($$dpth: number, cr?: ContextRecorder): Nullable<Keyword> {
        return this.choice<Keyword>([
            () => this.matchKeyword_1($$dpth + 1, cr),
            () => this.matchKeyword_2($$dpth + 1, cr),
            () => this.matchKeyword_3($$dpth + 1, cr),
            () => this.matchKeyword_4($$dpth + 1, cr),
            () => this.matchKeyword_5($$dpth + 1, cr),
            () => this.matchKeyword_6($$dpth + 1, cr),
            () => this.matchKeyword_7($$dpth + 1, cr),
            () => this.matchKeyword_8($$dpth + 1, cr),
            () => this.matchKeyword_9($$dpth + 1, cr),
            () => this.matchKeyword_10($$dpth + 1, cr),
        ]);
    }
    public matchKeyword_1($$dpth: number, cr?: ContextRecorder): Nullable<Keyword_1> {
        return this.regexAccept(String.raw`if`, $$dpth + 1, cr);
    }
    public matchKeyword_2($$dpth: number, cr?: ContextRecorder): Nullable<Keyword_2> {
        return this.regexAccept(String.raw`or`, $$dpth + 1, cr);
    }
    public matchKeyword_3($$dpth: number, cr?: ContextRecorder): Nullable<Keyword_3> {
        return this.regexAccept(String.raw`when`, $$dpth + 1, cr);
    }
    public matchKeyword_4($$dpth: number, cr?: ContextRecorder): Nullable<Keyword_4> {
        return this.regexAccept(String.raw`true`, $$dpth + 1, cr);
    }
    public matchKeyword_5($$dpth: number, cr?: ContextRecorder): Nullable<Keyword_5> {
        return this.regexAccept(String.raw`false`, $$dpth + 1, cr);
    }
    public matchKeyword_6($$dpth: number, cr?: ContextRecorder): Nullable<Keyword_6> {
        return this.regexAccept(String.raw`function`, $$dpth + 1, cr);
    }
    public matchKeyword_7($$dpth: number, cr?: ContextRecorder): Nullable<Keyword_7> {
        return this.regexAccept(String.raw`continue`, $$dpth + 1, cr);
    }
    public matchKeyword_8($$dpth: number, cr?: ContextRecorder): Nullable<Keyword_8> {
        return this.regexAccept(String.raw`void`, $$dpth + 1, cr);
    }
    public matchKeyword_9($$dpth: number, cr?: ContextRecorder): Nullable<Keyword_9> {
        return this.regexAccept(String.raw`return`, $$dpth + 1, cr);
    }
    public matchKeyword_10($$dpth: number, cr?: ContextRecorder): Nullable<Keyword_10> {
        return this.regexAccept(String.raw`object`, $$dpth + 1, cr);
    }
    public test(): boolean {
        const mrk = this.mark();
        const res = this.matchProgram(0);
        const ans = res !== null && this.finished();
        this.reset(mrk);
        return ans;
    }
    public parse(): ParseResult {
        const mrk = this.mark();
        const res = this.matchProgram(0);
        if (res && this.finished()) {
            return new ParseResult(res, null);
        }
        this.reset(mrk);
        const rec = new ErrorTracker();
        this.matchProgram(0, rec);
        return new ParseResult(res, rec.getErr());
    }
    private mark(): PosInfo {
        return this.pos;
    }
    private loop<T>(func: $$RuleType<T>, star: boolean = false): Nullable<T[]> {
        const mrk = this.mark();
        const res: T[] = [];
        for (;;) {
            const t = func();
            if (t === null) {
                break;
            }
            res.push(t);
        }
        if (star || res.length > 0) {
            return res;
        }
        this.reset(mrk);
        return null;
    }
    private runner<T>($$dpth: number, fn: $$RuleType<T>, cr?: ContextRecorder): $$RuleType<T> {
        return () => {
            const mrk = this.mark();
            const res = cr ? (() => {
                const extraInfo: string[] = [];
                const result = fn((msg: string) => extraInfo.push(msg));
                cr.record(mrk, $$dpth, result, this.negating, extraInfo);
                return result;
            })() : fn();
            if (res !== null) {
                return res;
            }
            this.reset(mrk);
            return null;
        };
    }
    private choice<T>(fns: Array<$$RuleType<T>>): Nullable<T> {
        for (const f of fns) {
            const res = f();
            if (res !== null) {
                return res;
            }
        }
        return null;
    }
    private regexAccept(match: string, dpth: number, cr?: ContextRecorder): Nullable<string> {
        return this.runner<string>(dpth,
            (log) => {
                if (log) {
                    if (this.negating) {
                        log("$$!StrMatch");
                    } else {
                        log("$$StrMatch");
                    }
                    log(match);
                }
                const reg = new RegExp(match, "y");
                reg.lastIndex = this.mark().overallPos;
                const res = reg.exec(this.input);
                if (res) {
                    let lineJmp = 0;
                    let lind = -1;
                    for (let i = 0; i < res[0].length; ++i) {
                        if (res[0][i] === "\n") {
                            ++lineJmp;
                            lind = i;
                        }
                    }
                    this.pos = {
                        overallPos: reg.lastIndex,
                        line: this.pos.line + lineJmp,
                        offset: lind === -1 ? this.pos.offset + res[0].length : (res[0].length - lind)
                    };
                    return res[0];
                }
                return null;
            }, cr)();
    }
    private noConsume<T>(fn: $$RuleType<T>): Nullable<T> {
        const mrk = this.mark();
        const res = fn();
        this.reset(mrk);
        return res;
    }
    private negate<T>(fn: $$RuleType<T>): Nullable<boolean> {
        const mrk = this.mark();
        const oneg = this.negating;
        this.negating = !oneg;
        const res = fn();
        this.negating = oneg;
        this.reset(mrk);
        return res === null ? true : null;
    }
}
export function parse(s: string): ParseResult {
    const p = new Parser(s);
    return p.parse();
}
export class ParseResult {
    public ast: Nullable<Program>;
    public err: Nullable<SyntaxErr>;
    constructor(ast: Nullable<Program>, err: Nullable<SyntaxErr>) {
        this.ast = ast;
        this.err = err;
    }
}
export interface PosInfo {
    readonly overallPos: number;
    readonly line: number;
    readonly offset: number;
}
export class SyntaxErr {
    public pos: PosInfo;
    public exprules: string[];
    public expmatches: string[];
    constructor(pos: PosInfo, exprules: Set<string>, expmatches: Set<string>) {
        this.pos = pos;
        this.exprules = [...exprules];
        this.expmatches = [...expmatches];
    }
    public toString(): string {
        return `Syntax Error at line ${this.pos.line}:${this.pos.offset}. Tried to match rules ${this.exprules.join(", ")}. Expected one of ${this.expmatches.map((x) => ` '${x}'`)}`;
    }
}
class ErrorTracker implements ContextRecorder {
    private mxpos: PosInfo = {overallPos: -1, line: -1, offset: -1};
    private mnd: number = -1;
    private prules: Set<string> = new Set();
    private pmatches: Set<string> = new Set();
    public record(pos: PosInfo, depth: number, result: any, negating: boolean, extraInfo: string[]) {
        if ((result === null) === negating) {
            return;
        }
        if (pos.overallPos > this.mxpos.overallPos) {
            this.mxpos = pos;
            this.mnd = depth;
            this.pmatches.clear();
            this.prules.clear();
        } else if (pos.overallPos === this.mxpos.overallPos && depth < this.mnd) {
            this.mnd = depth;
            this.prules.clear();
        }
        if (this.mxpos.overallPos === pos.overallPos && extraInfo.length >= 2) {
            if (extraInfo[0] === "$$StrMatch") {
                this.pmatches.add(extraInfo[1]);
            }
            if (extraInfo[0] === "$$!StrMatch") {
                this.pmatches.add(`not ${extraInfo[1]}`);
            }
        }
        if (this.mxpos.overallPos === pos.overallPos && this.mnd === depth) {
            extraInfo.forEach((x) => { if (x !== "$$StrMatch" && x !== "$$!StrMatch") { this.prules.add(x); } });
        }
    }
    public getErr(): SyntaxErr | null {
        if (this.mxpos.overallPos !== -1) {
            return new SyntaxErr(this.mxpos, this.prules, this.pmatches);
        }
        return null;
    }
}